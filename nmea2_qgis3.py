# -*- coding: utf-8 -*-
"""
/***************************************************************************
 nmea2qgis3
                                 A QGIS plugin
 Plugin importing nmea data into the qgis program
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-07-19
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Piotr Zyto
        email                : zidopiotr@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .nmea2_qgis3_dialog import nmea2qgis3Dialog
import os.path


class nmea2qgis3:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'nmea2qgis3_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = nmea2qgis3Dialog()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Nmea2 Qgis3')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'nmea2qgis3')
        self.toolbar.setObjectName(u'nmea2qgis3')

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('nmea2qgis3', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/nmea2_qgis3/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Nmea2 Qgis3'),
            callback=self.run,
            parent=self.iface.mainWindow())


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Nmea2 Qgis3'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar


    def run(self):
        """Run method that performs all the real work"""
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

#------------------------------testowanie---------------------------
# dodaje atrybuty do porogramu
    def addLayer(self):

        for filename in self.filenames:
            ##            try:
            nmeafile = open(filename)
            self.nmeaDict(nmeafile)
            self.addSave(filename)

##            except:
##                if self.dlg.ui.lineEdit.text()=='': QMessageBox.information(self.iface.mainWindow(), "Info", "Cannot add nmealayer, \ncheck the file path")
##                else:   QMessageBox.information(self.iface.mainWindow(), "Info", "Cannot add nmealayer")

# sprawdza czy, linie zdań nalezą do GGA,RMC,GLL jesli prwda to funkcja wywoluje funkcje parsowania    def nmeaDict(self,nmeafile):

    def nmeaDict(self,nmeafile):
        self.nl=self.dlg3.ui.nullBox.value()
        nl=self.nl
        self.nmeadict={}
        nmeafile.seek(0)
        self.dlg.close()
        for line in nmeafile:
             linee=line.split(',')
             if line[3:6]=='GGA' or line[3:6]=='RMC':
                 self.nmeadict[linee[1]]=['',nl,nl,nl,nl,nl,nl,nl,nl,nl,nl]
             if line[3:6]=='GLL':
                 self.nmeadict[linee[5]]=['',nl,nl,nl,nl,nl,nl,nl,nl,nl,nl]

        nmeafile.seek(0)
        for line in nmeafile:
            if line[3:6]=='GGA' or line[3:6]=='GLL' or line[3:6]=='RMC':
                try:
                    parser={'GGA':self.par_gga,'RMC':self.par_rmc,'GLL':self.par_gll}[line[3:6]]
                    parser(line)
                except:
                    QMessageBox.critical(self.iface.mainWindow(), 'error', "problem parsing line:  "+line)
                    break



        nmeafile.close()

        self.utc=[]
        self.lat=[]
        self.lon=[]
        self.numSV=[]
        self.hdop=[]
        self.msl=[]
        self.geoid=[]
        self.speed=[]
        self.fixstatus=[]
        self.datastatus=[]

        for keyy in self.nmeadict.keys():
            self.utc.append(self.nmeadict[keyy][0])
            self.numSV.append((self.nmeadict[keyy][3]))
            self.hdop.append((self.nmeadict[keyy][4]))
            self.lon.append(self.nmeadict[keyy][2])
            self.lat.append(self.nmeadict[keyy][1])
            self.msl.append((self.nmeadict[keyy][5]))
            self.geoid.append((self.nmeadict[keyy][6]))
            self.speed.append((self.nmeadict[keyy][7]))
            self.fixstatus.append(int(self.nmeadict[keyy][9]))
            self.datastatus.append(self.nmeadict[keyy][10])



    def addSave(self,filename):
        import ntpath
        try:
            layername=ntpath.basename(str(filename))

        except:
            layername="nmealayer"


        self.epsg4326= QgsCoordinateReferenceSystem()
        self.epsg4326.createFromString("epsg:4326")
        nmealayer = QgsVectorLayer("Point?crs=epsg:4326", layername, "memory")
        nmealayer.startEditing()

        pr = nmealayer.dataProvider()
        att=[]
        a=0
        if self.dlg3.ui.latCheck.isChecked():
               pr.addAttributes( [ QgsField("latitude", QVariant.Double)] )
               att.append(self.lat)
               a+=1
        if self.dlg3.ui.lonCheck.isChecked():
               pr.addAttributes( [ QgsField("longitude", QVariant.Double)] )
               att.append(self.lon)
               a+=1
        if self.dlg3.ui.utcCheck.isChecked():
               pr.addAttributes( [ QgsField("utc", QVariant.String)] )
               att.append(self.utc)
               a+=1
        if self.dlg3.ui.svCheck.isChecked():
               pr.addAttributes( [ QgsField("numSV", QVariant.Double)] )
               att.append(self.numSV)
               a+=1
        if self.dlg3.ui.hdopCheck.isChecked():
               pr.addAttributes( [ QgsField("hdop", QVariant.Double)] )
               att.append(self.hdop)
               a+=1
        if self.dlg3.ui.mslCheck.isChecked():
               pr.addAttributes( [ QgsField("msl", QVariant.Double)] )
               att.append(self.msl)
               a+=1
        if self.dlg3.ui.geoidCheck.isChecked():
               pr.addAttributes( [ QgsField("geoid", QVariant.Double)] )
               att.append(self.geoid)
               a+=1
        if self.dlg3.ui.speedCheck.isChecked():
               pr.addAttributes( [ QgsField("speed", QVariant.Double)] )
               att.append(self.speed)
               a+=1
        if self.dlg3.ui.fixstatusCheck.isChecked():
               pr.addAttributes( [ QgsField("fixstatus", QVariant.Double)] )
               att.append(self.fixstatus)
               a+=1
        if self.dlg3.ui.datastatusCheck.isChecked():
               pr.addAttributes( [ QgsField("datastatus", QVariant.Double)] )
               att.append(self.datastatus)
               a+=1



        fett=[]
        for a,lat in enumerate(self.lat):
            fet = QgsFeature()
            fet.setGeometry(QgsGeometry.fromPoint(QgsPoint(self.lon[a],lat)))
            attributess=[]
            for aa in att:
                attributess.append(aa[a])
            fet.setAttributes(attributess)
            fett.append(fet)


        pr.addFeatures(fett)

        nmealayer.commitChanges()
        nmealayer.updateExtents()
        QgsMapLayerRegistry.instance().addMapLayer(nmealayer)
        if self.dlg3.ui.saveCheck.isChecked():
            self.filename = self.fd.getSaveFileName()
            error = QgsVectorFileWriter.writeAsVectorFormat(nmealayer, self.filename, "CP1250", self.epsg4326, "ESRI Shapefile")

        self.iface.mapCanvas().zoomToFullExtent()

#fukcja parsowania poszczególnych zdań nmea
    def par_gga(self,line):
        data=[]
        data=line.split(',')
        key=data[1]
        utc=data[1][:2]+':'+data[1][2:4]+':'+data[1][4:6]
        if data[3]=='N':
            latt=float(data[2][:2])+float(data[2][2:])/60
        elif data[3]=='S':
            latt=-1*float(data[2][:2])+float(data[2][2:])/60
        else:
            latt=self.nl
        ind=string.find(data[4],".")
        if data[5]=='E':
            lonn=float(data[4][:(ind-2)])+float(data[4][(ind-2):])/60
        elif data[5]=='W':
            lonn=-1*float(data[4][:(ind-2)])+float(data[4][(ind-2):])/60
        else:
            lonn=self.nl
        try:    numsv=float(data[7])
        except: numsv=self.nl
        try:    hdop=float(data[8])
        except: hdop=self.nl
        try:    msl=float(data[9])
        except: msl=self.nl
        try:    geoid=float(data[11])
        except: geoid=self.nl
        try:    fixstatus=float(data[6])
        except: fixstatus=self.nl

        self.nmeadict[key][0]=utc
        self.nmeadict[key][1]=latt
        self.nmeadict[key][2]=lonn
        self.nmeadict[key][3]=numsv
        self.nmeadict[key][4]=hdop
        self.nmeadict[key][5]=msl
        self.nmeadict[key][6]=geoid
        self.nmeadict[key][9]=fixstatus

    def par_rmc(self,line):
        data=[]
        data=line.split(',')
        key=data[1]
        utc=data[1][:2]+':'+data[1][2:4]+':'+data[1][4:6]
        if data[4]=='N':
            latt=float(data[3][:2])+float(data[3][2:])/60
        elif data[4]=="S":
            latt=-1*float(data[3][:2])+float(data[3][2:])/60
        else:
            latt=self.nl
        ind=string.find(data[5],".")
        if data[6]=='E':
            lonn=float(data[5][:(ind-2)])+float(data[5][(ind-2):])/60
        elif data[6]=='W':
            lonn=-1*float(data[5][:(ind-2)])+float(data[5][(ind-2):])/60
        else:
            lonn=self.nl
        try:    speed=float(data[7])
        except: speed=self.nl
        try:
            if data[2]=='A':    datastatus=1
            else:   datastatus=0
        except: datastatus=self.nl

        self.nmeadict[key][0]=utc
        self.nmeadict[key][1]=latt
        self.nmeadict[key][2]=lonn
        self.nmeadict[key][7]=speed
        self.nmeadict[key][10]=datastatus

    def par_gll(self,line):
        data=[]
        data=line.split(',')
        key=data[5]
        utc=data[5][:2]+':'+data[5][2:4]+':'+data[5][4:6]
        if data[2]=='N':
            latt=float(data[1][:2])+float(data[1][2:])/60
        elif data[2]=='S':
            latt=-1*float(data[1][:2])+float(data[1][2:])/60
        else:
            latt=self.nl
        ind=string.find(data[3],".")
        if data[4]=='E':
            lonn=float(data[3][:(ind-2)])+float(data[3][(ind-2):])/60
        elif data[4]=='W':
            lonn=-1*float(data[3][:(ind-2)])+float(data[3][(ind-2):])/60
        else:
            lonn=self.nl
        try:
            if data[6]=='A':    datastatus=1
            else:   datastatus=0
        except: datastatus=self.nl

        self.nmeadict[key][0]=utc
        self.nmeadict[key][1]=latt
        self.nmeadict[key][2]=lonn
        self.nmeadict[key][10]=datastatus

